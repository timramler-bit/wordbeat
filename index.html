<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tim the Teacher - Word on Beat</title>
    
    <!-- PWA Settings -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0f172a">
    
    <!-- Icons (SVG Data URI for single-file portability) -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üë®‚Äçüè´</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22 style=%22background-color: %230f172a;%22><rect width=%22100%22 height=%22100%22 fill=%22%230f172a%22/><text x=%2250%25%22 y=%2250%25%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 font-size=%2270%22>üë®‚Äçüè´</text></svg>">

    <!-- Manifest -->
    <link rel="manifest" href="data:application/manifest+json;base64,ewogICAgIm5hbWUiOiAiVGltIHRoZSBUZWFjaGVyIC0gV29yZCBCZWF0IiwKICAgICJzaG9ydF9uYW1lIjogIldvcmRCZWF0IiwKICAgICJzdGFydF91cmwiOiAiLiIsCiAgICAiZGlzcGxheSI6ICJzdGFuZGFsb25lIiwKICAgICJiYWNrZ3JvdW5kX2NvbG9yIjogIiMwZjE3MmEiLAogICAgInRoZW1lX2NvbG9yIjogIiMwZjE3MmEiLAogICAgImljb25zIjogWwogICAgICAgIHsKICAgICAgICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTV3Y204dkyM3dMbTloWVR4d2FXMWxQeUoyYVdWM1ltOXRQeTgwSUhKbFkzUWdZMjl1ZEdWdWRDQTlJalEwTWpZaUlHZGhhV3d2UGp4emRHbHNaVDxsSW1WaWJHbHdhV1VnZEdWNGRDMW5aWE56SUhObGNuWnBZMkVnSW5OMllXNWhKMTB5TWk1NWJXVjBieTlpWVdOclozSnZkVzVrWDJadmJtUXRjMmw2WlRvaU56QWlQZzRiOUNrd29KNGQybGxMbTFoT2o4dmMzWm5QZz09IiwKICAgICAgICAgICAgInNpemVzIjogIjE5MngxOTIiLAogICAgICAgICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIgogICAgICAgIH0KICAgIF0KfQ==">

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Poppins:wght@500;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* slate-900 */
            color: #f1f5f9; /* slate-100 */
            touch-action: manipulation;
            overscroll-behavior: none; /* Prevents bounce on iOS */
        }

        .font-poppins {
            font-family: 'Poppins', sans-serif;
        }

        /* Card Animations */
        .card {
            transition: all 0.1s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .card-active {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(59, 130, 246, 0.5); /* Blue glow to match brand */
            border-color: #60a5fa !important; /* blue-400 */
            background-color: #1e293b !important; /* slate-800 */
            z-index: 10;
        }

        /* Removed opacity reduction for inactive cards per request */
        .card-inactive {
            /* No dimming */
        }

        /* Custom Slider Styling */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #3b82f6; /* Blue-500 */
            cursor: pointer;
            margin-top: -6px; 
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
            transition: box-shadow 0.2s;
        }

        input[type=range]::-webkit-slider-thumb:hover {
            box-shadow: 0 0 0 5px rgba(59, 130, 246, 0.3);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #334155;
            border-radius: 2px;
        }

        /* Pulse for Start Button */
        @keyframes pulse-ring {
            0% { transform: scale(0.8); opacity: 0.5; }
            100% { transform: scale(1.3); opacity: 0; }
        }
        
        .btn-pulse::before {
            content: '';
            position: absolute;
            left: 0; top: 0;
            width: 100%; height: 100%;
            background-color: inherit;
            border-radius: inherit;
            z-index: -1;
            animation: pulse-ring 1.5s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
        }

        /* Custom Select Styling */
        select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%2394a3b8' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
            -webkit-appearance: none;
            appearance: none;
        }

        /* Modal Transitions */
        .modal-enter { opacity: 0; pointer-events: none; transform: scale(0.95); }
        .modal-active { opacity: 1; pointer-events: auto; transform: scale(1); }
        
        /* Scrollbar for modal */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #1e293b; 
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #475569; 
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #64748b; 
        }
        
        /* Toggle Switch */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #3b82f6; /* Blue */
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #3b82f6; /* Blue */
        }
        
        /* Checkbox Custom Style */
        .custom-checkbox:checked {
            background-color: #3b82f6;
            border-color: #3b82f6;
        }
        .custom-checkbox:checked:after {
            content: '‚úì';
            color: white;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <!-- Control Panel -->
    <header class="flex-none bg-slate-900 border-b border-slate-800 z-20 shadow-xl">
        <div class="max-w-7xl mx-auto p-4">
            <div class="flex flex-col xl:flex-row items-center justify-between gap-4">
                
                <!-- Branding -->
                <div class="flex items-center gap-3 select-none flex-shrink-0">
                    <div class="w-12 h-12 bg-slate-800 rounded-xl flex items-center justify-center text-3xl shadow-lg border border-slate-700">üë®‚Äçüè´</div>
                    <div class="flex flex-col">
                        <h1 class="font-poppins font-medium text-blue-500 text-2xl tracking-tight leading-none">Tim the Teacher</h1>
                        <span class="text-[10px] text-slate-500 font-bold tracking-widest uppercase mt-1">Word on the Beat</span>
                    </div>
                </div>

                <!-- Settings Container -->
                <div class="flex flex-col md:flex-row flex-1 items-center gap-4 w-full bg-slate-800/50 p-2 md:p-3 rounded-2xl border border-slate-700/50 backdrop-blur-sm overflow-x-auto">
                    
                    <!-- Vocabulary Dropdown Group -->
                    <div class="flex items-end gap-2 flex-1 min-w-[170px]">
                        <div class="flex flex-col gap-1 flex-1">
                            <label class="text-[10px] font-bold text-slate-400 tracking-wider">VOCABULARY</label>
                            <select id="vocabSelect" class="w-full bg-slate-800 border border-slate-600 text-white text-xs rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2">
                                <option value="animals">ü¶Å Animals</option>
                                <option value="nature">üå≥ Nature</option>
                                <option value="food">üçï Food</option>
                                <option value="objects">üé∏ Objects</option>
                                <option value="places">üè† Places</option>
                                <option value="colors">üé® Colors</option>
                                <option value="numbers">1Ô∏è‚É£ Numbers</option>
                                <option value="alphabet">üî§ Alphabet</option>
                                <option value="feelings">üòÑ Feelings</option>
                            </select>
                        </div>
                        <button id="filterBtn" class="bg-slate-700 hover:bg-slate-600 text-white p-2 rounded-lg border border-slate-600 h-[34px] w-[34px] flex items-center justify-center transition-colors mb-[1px]" title="Select Words">
                            <span>üå™Ô∏è</span>
                        </button>
                    </div>

                    <!-- Grammar Dropdown -->
                    <div class="flex flex-col gap-1 min-w-[140px] flex-1">
                        <label class="text-[10px] font-bold text-slate-400 tracking-wider">GRAMMAR</label>
                        <select id="grammarSelect" class="w-full bg-slate-800 border border-slate-600 text-white text-xs rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2">
                            <option value="none">--- Word Only ---</option>
                            <option value="svo_like">SVO (I like...)</option>
                            <option value="svo_see">SVO (I see a...)</option>
                            <option value="prep_on">Prep (On the...)</option>
                            <option value="prep_under">Prep (Under the...)</option>
                            <option value="comp_than">Comp (Bigger than...)</option>
                            <option value="passive">Passive (The... was seen)</option>
                        </select>
                    </div>

                    <!-- Sliders Group -->
                    <div class="flex gap-4 flex-1">
                        <!-- BPM -->
                        <div class="flex flex-col gap-1 min-w-[70px] flex-1">
                            <div class="flex justify-between text-[10px] font-bold text-slate-400 tracking-wider">
                                <span>SPEED</span>
                                <span id="bpmDisplay" class="text-blue-400">90</span>
                            </div>
                            <input type="range" id="bpmSlider" min="40" max="160" value="90" step="5" class="w-full">
                        </div>

                        <!-- Grid Count -->
                        <div class="flex flex-col gap-1 min-w-[70px] flex-1">
                            <div class="flex justify-between text-[10px] font-bold text-slate-400 tracking-wider">
                                <span>CARDS</span>
                                <span id="gridDisplay" class="text-blue-400">8</span>
                            </div>
                            <input type="range" id="gridSlider" min="2" max="16" value="8" step="1" class="w-full">
                        </div>

                        <!-- Pool Size (New) -->
                        <div class="flex flex-col gap-1 min-w-[70px] flex-1">
                            <div class="flex justify-between text-[10px] font-bold text-slate-400 tracking-wider">
                                <span>POOL</span>
                                <span id="poolDisplay" class="text-blue-400">8</span>
                            </div>
                            <input type="range" id="poolSlider" min="2" max="16" value="8" step="1" class="w-full">
                        </div>
                    </div>

                    <!-- Emoji Toggle -->
                    <div class="flex flex-col gap-1 items-center justify-center">
                        <label class="text-[10px] font-bold text-slate-400 tracking-wider">EMOJI</label>
                        <div class="relative inline-block w-10 h-5 align-middle select-none transition duration-200 ease-in">
                            <input type="checkbox" name="emojiToggle" id="emojiToggle" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer border-slate-600 transition-all duration-300 left-0 checked:left-5 checked:border-blue-600" checked/>
                            <label for="emojiToggle" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-700 cursor-pointer"></label>
                        </div>
                    </div>

                    <!-- Action Buttons -->
                    <div class="flex items-center gap-2">
                        <button id="editBtn" class="px-3 py-2 rounded-lg bg-slate-700 hover:bg-slate-600 text-xs font-bold text-white transition-colors flex items-center gap-2 whitespace-nowrap h-[38px]">
                            <span>‚úé</span>
                        </button>
                        
                        <button id="previewBtn" class="px-3 py-2 rounded-lg bg-blue-600 hover:bg-blue-500 text-xs font-bold text-white transition-colors flex items-center gap-2 whitespace-nowrap h-[38px]">
                            <span>üìñ</span>
                        </button>

                        <button id="shuffleBtn" class="p-2 rounded-lg bg-slate-700 hover:bg-slate-600 text-slate-300 transition-colors h-[38px] w-[38px] flex items-center justify-center" title="Shuffle Words">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line></svg>
                        </button>
                    </div>

                </div>

                <!-- Start/Stop Button -->
                <button id="toggleBtn" class="flex-shrink-0 relative overflow-hidden group bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-8 rounded-xl transition-all active:scale-95 shadow-lg shadow-blue-900/30 w-full md:w-auto min-w-[120px]">
                    <span id="btnText" class="flex items-center justify-center gap-2 tracking-wide">
                        <span>‚ñ∂</span> START
                    </span>
                </button>
            </div>
        </div>
    </header>

    <!-- Game Board -->
    <main class="flex-1 relative bg-slate-950 flex flex-col items-center justify-center p-4">
        
        <!-- Status -->
        <div id="statusText" class="absolute top-6 text-blue-400 font-mono text-sm tracking-[0.2em] uppercase opacity-0 transition-opacity font-bold z-20">
            ROUND 1/5
        </div>

        <!-- Overlay Text (Smaller) -->
        <div id="overlayContainer" class="absolute inset-0 flex items-center justify-center pointer-events-none z-50 opacity-0 transition-opacity duration-300">
             <div id="overlayContent" class="text-3xl md:text-4xl font-bold text-white drop-shadow-xl tracking-wider bg-slate-900/90 px-6 py-3 rounded-full border border-white/20 backdrop-blur-md transform scale-90 transition-transform duration-150 text-center shadow-2xl">
                MEMORIZE
             </div>
        </div>

        <!-- Grid -->
        <div id="gameGrid" class="grid gap-3 w-full max-w-6xl transition-all duration-300">
            <!-- Content Injected via JS -->
        </div>

    </main>

    <!-- Custom Words Modal -->
    <div id="customModal" class="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm modal-enter transition-all duration-200">
        <div class="bg-slate-900 border border-slate-700 rounded-2xl p-6 w-full max-w-lg shadow-2xl m-4">
            <h2 class="text-xl font-bold text-white mb-2">Custom Words</h2>
            <div class="text-sm text-slate-400 mb-4 space-y-1">
                <p>‚Ä¢ Separate words with <strong>spaces</strong> (e.g., Apple Banana Cherry).</p>
                <p>‚Ä¢ Use a <strong>new line</strong> for each Round.</p>
                <p>‚Ä¢ Colors will be highlighted automatically.</p>
            </div>
            
            <textarea id="customInput" class="w-full h-40 bg-slate-800 border border-slate-700 rounded-xl p-4 text-white placeholder-slate-500 focus:outline-none focus:border-blue-500 resize-none font-mono text-sm whitespace-pre" placeholder="Apple Red Green Blue&#10;Yellow Purple Orange Pink&#10;Black White Gold Silver"></textarea>
            
            <div class="flex gap-3 mt-6">
                <button id="cancelCustomBtn" class="flex-1 py-3 rounded-xl font-bold text-slate-400 hover:bg-slate-800 transition-colors">Cancel</button>
                <button id="applyCustomBtn" class="flex-1 py-3 rounded-xl font-bold bg-blue-600 hover:bg-blue-500 text-white shadow-lg shadow-blue-900/20 transition-colors">Use Custom Words</button>
            </div>
        </div>
    </div>

    <!-- Selection Modal (New) -->
    <div id="selectionModal" class="fixed inset-0 z-50 flex items-center justify-center bg-black/90 backdrop-blur-sm modal-enter transition-all duration-200">
        <div class="bg-slate-900 border border-slate-700 rounded-2xl p-6 w-full max-w-lg shadow-2xl m-4 flex flex-col max-h-[85vh]">
            <h2 class="text-xl font-bold text-white mb-2">Select Words</h2>
            <p class="text-sm text-slate-400 mb-4">Choose specific words for this category. If none selected, random words are used.</p>
            
            <div id="selectionList" class="flex-1 overflow-y-auto custom-scrollbar bg-slate-800 rounded-xl p-2 grid grid-cols-2 gap-2">
                <!-- Checkboxes injected here -->
            </div>
            
            <div class="mt-4 flex gap-3">
                <button id="closeSelectionBtn" class="flex-1 py-2 rounded-xl font-bold text-slate-400 hover:bg-slate-800 transition-colors">Cancel</button>
                <button id="saveSelectionBtn" class="flex-1 py-2 rounded-xl font-bold bg-blue-600 hover:bg-blue-500 text-white shadow-lg transition-colors">Save</button>
            </div>
        </div>
    </div>

    <!-- Preview Modal -->
    <div id="previewModal" class="fixed inset-0 z-50 flex items-center justify-center bg-black/90 backdrop-blur-sm modal-enter transition-all duration-200">
        <div class="bg-slate-900 border border-slate-700 rounded-2xl p-6 w-full max-w-2xl shadow-2xl m-4 flex flex-col items-center relative">
            <button id="closePreviewBtn" class="absolute top-4 right-4 text-slate-400 hover:text-white text-xl">‚úï</button>
            
            <h2 class="text-xl font-bold text-white mb-6">Vocabulary Preview</h2>
            
            <!-- Carousel Container -->
            <div class="flex items-center justify-center w-full gap-4">
                <button id="prevCardBtn" class="p-3 text-slate-400 hover:text-white hover:bg-slate-800 rounded-full transition-all">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
                </button>
                
                <div id="flashcardContainer" class="w-64 h-80 relative perspective-1000">
                    <!-- Single Card Injected Here -->
                </div>

                <button id="nextCardBtn" class="p-3 text-slate-400 hover:text-white hover:bg-slate-800 rounded-full transition-all">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
                </button>
            </div>
            
            <div id="previewCounter" class="mt-4 text-slate-500 font-mono text-sm">1 / 5</div>
        </div>
    </div>

    <script>
        /**
         * VOCABULARY SETS
         */
        const VOCAB_SETS = {
            "animals": ["Monkey", "Tiger", "Giraffe", "Zebra", "Snake", "Bear", "Penguin", "Lion", "Frog", "Turtle", "Cat", "Dog", "Fish", "Bird", "Elephant", "Fox", "Rabbit"],
            "nature": ["Hill", "Rock", "Flower", "Tree", "Lake", "River", "Sun", "Moon", "Star", "Cloud", "Forest", "Mountain", "Beach", "Ocean"],
            "food": ["Pizza", "Burger", "Apple", "Banana", "Sushi", "Rice", "Bread", "Cake", "IceCream", "Milk", "Egg", "Cheese", "Cookie", "Donut"],
            "objects": ["Book", "Pen", "Computer", "Phone", "Car", "Bus", "Bike", "Ball", "Guitar", "Piano", "Clock", "Key", "Shoe", "Hat"],
            "places": ["School", "Park", "Home", "Shop", "Zoo", "City", "Beach", "Kitchen", "Room", "Garden"],
            "colors": ["Red", "Blue", "Green", "Yellow", "Orange", "Purple", "Pink", "Black", "White", "Brown"],
            "numbers": ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten"],
            "alphabet": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"],
            "feelings": ["Happy", "Sad", "Angry", "Sleepy", "Hungry", "Thirsty", "Hot", "Cold", "Tired", "Sick", "Scared", "Excited"]
        };

        /**
         * COMPREHENSIVE EMOJI DB
         */
        const EMOJI_DB = [
            // Animals
            {t:"Monkey",e:"üêµ"}, {t:"Tiger",e:"üêØ"}, {t:"Giraffe",e:"ü¶í"}, {t:"Zebra",e:"ü¶ì"}, {t:"Snake",e:"üêç"}, 
            {t:"Bear",e:"üêª"}, {t:"Penguin",e:"üêß"}, {t:"Lion",e:"ü¶Å"}, {t:"Frog",e:"üê∏"}, {t:"Turtle",e:"üê¢"},
            {t:"Cat",e:"üê±"}, {t:"Dog",e:"üê∂"}, {t:"Fish",e:"üêü"}, {t:"Bird",e:"üê¶"}, {t:"Elephant",e:"üêò"},
            {t:"Fox",e:"ü¶ä"}, {t:"Rabbit",e:"üê∞"},
            // Nature
            {t:"Hill",e:"‚õ∞Ô∏è"}, {t:"Rock",e:"ü™®"}, {t:"Flower",e:"üå∏"}, {t:"Tree",e:"üå≥"}, {t:"Lake",e:"üèûÔ∏è"}, 
            {t:"River",e:"üåä"}, {t:"Sun",e:"‚òÄÔ∏è"}, {t:"Moon",e:"üåô"}, {t:"Star",e:"‚≠ê"}, {t:"Cloud",e:"‚òÅÔ∏è"},
            {t:"Forest",e:"üå≤"}, {t:"Mountain",e:"üèîÔ∏è"}, {t:"Beach",e:"üèñÔ∏è"}, {t:"Ocean",e:"üåä"},
            // Food
            {t:"Pizza",e:"üçï"}, {t:"Burger",e:"üçî"}, {t:"Apple",e:"üçé"}, {t:"Banana",e:"üçå"}, {t:"Sushi",e:"üç£"},
            {t:"Rice",e:"üçö"}, {t:"Bread",e:"üçû"}, {t:"Cake",e:"üéÇ"}, {t:"IceCream",e:"üç¶"}, {t:"Milk",e:"ü•õ"},
            {t:"Egg",e:"ü•ö"}, {t:"Cheese",e:"üßÄ"}, {t:"Cookie",e:"üç™"}, {t:"Donut",e:"üç©"},
            // Objects
            {t:"Book",e:"üìñ"}, {t:"Pen",e:"üñäÔ∏è"}, {t:"Computer",e:"üíª"}, {t:"Phone",e:"üì±"}, {t:"Car",e:"üöó"},
            {t:"Bus",e:"üöå"}, {t:"Bike",e:"üö≤"}, {t:"Ball",e:"‚öΩ"}, {t:"Guitar",e:"üé∏"}, {t:"Piano",e:"üéπ"},
            {t:"Clock",e:"‚è∞"}, {t:"Key",e:"üîë"}, {t:"Shoe",e:"üëü"}, {t:"Hat",e:"üß¢"},
            // Places
            {t:"School",e:"üè´"}, {t:"Park",e:"üõù"}, {t:"Home",e:"üè†"}, {t:"Shop",e:"üè™"}, {t:"Zoo",e:"ü¶Å"},
            {t:"City",e:"üèôÔ∏è"}, {t:"Kitchen",e:"üç≥"}, {t:"Room",e:"üõèÔ∏è"}, {t:"Garden",e:"üåª"},
            // Colors
            {t:"Red",e:"üî¥"},{t:"Blue",e:"üîµ"},{t:"Green",e:"üü¢"},{t:"Yellow",e:"üü°"},
            {t:"Orange",e:"üü†"},{t:"Purple",e:"üü£"},{t:"Black",e:"‚ö´"},{t:"White",e:"‚ö™"},
            {t:"Brown",e:"üü§"},{t:"Pink",e:"ü©∑"},
            // Numbers
            {t:"One",e:"1Ô∏è‚É£"},{t:"Two",e:"2Ô∏è‚É£"},{t:"Three",e:"3Ô∏è‚É£"},{t:"Four",e:"4Ô∏è‚É£"},{t:"Five",e:"5Ô∏è‚É£"},
            {t:"Six",e:"6Ô∏è‚É£"},{t:"Seven",e:"7Ô∏è‚É£"},{t:"Eight",e:"8Ô∏è‚É£"},{t:"Nine",e:"9Ô∏è‚É£"},{t:"Ten",e:"üîü"},
            // Feelings
            {t:"Happy",e:"üòÑ"},{t:"Sad",e:"üò¢"},{t:"Angry",e:"üò†"},{t:"Sleepy",e:"üò¥"},{t:"Hungry",e:"üòã"},
            {t:"Thirsty",e:"ü•§"},{t:"Hot",e:"ü•µ"},{t:"Cold",e:"ü•∂"},{t:"Tired",e:"üò´"},{t:"Sick",e:"ü§¢"},
            {t:"Scared",e:"üò±"},{t:"Excited",e:"ü§©"}
        ];

        // Create Map for fast lookup
        const EMOJI_MAP = new Map();
        EMOJI_DB.forEach(item => {
            EMOJI_MAP.set(item.t.toLowerCase(), item.e);
        });

        // --- State ---
        let audioCtx = null;
        let isPlaying = false;
        let nextNoteTime = 0.0;
        let timerID = null;
        let currentBeatIndex = 0; 
        
        let bpm = 90;
        let itemCount = 8;
        const LOOKAHEAD = 25.0; // ms
        const SCHEDULE_AHEAD_TIME = 0.1; // s

        // Data Management
        let isCustomMode = false;
        let customRoundsData = []; 
        let totalRounds = 5;
        let poolSize = 8; 
        let sessionPool = []; 
        let showEmojis = true;
        
        // Category Selection State
        // Store selected words for each category key
        const categorySelections = {}; 

        // Round Logic
        let currentRound = 1;
        let currentLoop = 1; 
        const LOOPS_PER_ROUND = 2; 

        // Intermission State
        let isIntermission = false;
        let intermissionCounter = 0;
        
        // Loop Transition State
        let isLoopTransition = false;
        let loopTransitionCounter = 0;

        // Finish State
        let finishingCounter = 0;

        // Audio Buffers
        let noiseBuffer = null;

        // Preview State
        let currentPreviewIndex = 0;

        // --- Elements ---
        const bpmSlider = document.getElementById('bpmSlider');
        const bpmDisplay = document.getElementById('bpmDisplay');
        const gridSlider = document.getElementById('gridSlider');
        const gridDisplay = document.getElementById('gridDisplay');
        const poolSlider = document.getElementById('poolSlider');
        const poolDisplay = document.getElementById('poolDisplay');
        const toggleBtn = document.getElementById('toggleBtn');
        const btnText = document.getElementById('btnText');
        const gameGrid = document.getElementById('gameGrid');
        const statusText = document.getElementById('statusText');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const editBtn = document.getElementById('editBtn');
        const previewBtn = document.getElementById('previewBtn');
        const filterBtn = document.getElementById('filterBtn');
        const emojiToggle = document.getElementById('emojiToggle');
        
        const vocabSelect = document.getElementById('vocabSelect');
        const grammarSelect = document.getElementById('grammarSelect');
        
        const customModal = document.getElementById('customModal');
        const customInput = document.getElementById('customInput');
        const cancelCustomBtn = document.getElementById('cancelCustomBtn');
        const applyCustomBtn = document.getElementById('applyCustomBtn');

        const selectionModal = document.getElementById('selectionModal');
        const selectionList = document.getElementById('selectionList');
        const closeSelectionBtn = document.getElementById('closeSelectionBtn');
        const saveSelectionBtn = document.getElementById('saveSelectionBtn');

        const overlayContainer = document.getElementById('overlayContainer');
        const overlayContent = document.getElementById('overlayContent');

        const previewModal = document.getElementById('previewModal');
        const flashcardContainer = document.getElementById('flashcardContainer');
        const closePreviewBtn = document.getElementById('closePreviewBtn');
        const prevCardBtn = document.getElementById('prevCardBtn');
        const nextCardBtn = document.getElementById('nextCardBtn');
        const previewCounter = document.getElementById('previewCounter');

        // --- Audio Engine ---
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            if (!noiseBuffer) {
                const bufferSize = audioCtx.sampleRate * 2; 
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noiseBuffer = buffer;
            }
        }

        // SYNTH INSTRUMENTS (Kick, Snare, HiHat, Bass, Stick)
        function playKick(time) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
            gain.gain.setValueAtTime(1, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
            osc.start(time);
            osc.stop(time + 0.5);
        }
        function playSnare(time) {
            const noise = audioCtx.createBufferSource();
            noise.buffer = noiseBuffer;
            const noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.value = 1000;
            const noiseGain = audioCtx.createGain();
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            noiseGain.gain.setValueAtTime(0.8, time);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
            noise.start(time);
            noise.stop(time + 0.2);
            const osc = audioCtx.createOscillator();
            const oscGain = audioCtx.createGain();
            osc.type = 'triangle';
            osc.connect(oscGain);
            oscGain.connect(audioCtx.destination);
            osc.frequency.setValueAtTime(250, time);
            oscGain.gain.setValueAtTime(0.5, time);
            oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
            osc.start(time);
            osc.stop(time + 0.1);
        }
        function playHiHat(time) {
            const noise = audioCtx.createBufferSource();
            noise.buffer = noiseBuffer;
            const noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.value = 5000;
            const noiseGain = audioCtx.createGain();
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            noiseGain.gain.setValueAtTime(0.3, time);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
            noise.start(time);
            noise.stop(time + 0.05);
        }
        function playBass(time, freq) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'triangle';
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.setValueAtTime(freq, time);
            gain.gain.setValueAtTime(0.4, time);
            gain.gain.linearRampToValueAtTime(0.3, time + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
            osc.start(time);
            osc.stop(time + 0.3);
        }
        function playStick(time, highPitch = false) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const freq = highPitch ? 1200 : 800;
            osc.frequency.setValueAtTime(freq, time);
            gain.gain.setValueAtTime(0.1, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
            osc.start(time);
            osc.stop(time + 0.05);
        }
        function playChord(time) {
             const notes = [523.25, 659.25, 783.99]; 
             notes.forEach((freq, i) => {
                 const osc = audioCtx.createOscillator();
                 const gain = audioCtx.createGain();
                 osc.type = 'triangle';
                 osc.frequency.value = freq;
                 osc.connect(gain);
                 gain.connect(audioCtx.destination);
                 gain.gain.setValueAtTime(0, time);
                 gain.gain.linearRampToValueAtTime(0.2, time + 0.05);
                 gain.gain.exponentialRampToValueAtTime(0.001, time + 1.5);
                 osc.start(time);
                 osc.stop(time + 1.5);
             });
        }

        // --- Data Logic ---
        function initSessionPool() {
            if (isCustomMode) {
                const allWords = customRoundsData.flat();
                const uniqueMap = new Map();
                allWords.forEach(w => uniqueMap.set(w.t, w));
                sessionPool = Array.from(uniqueMap.values());
            } else {
                const key = vocabSelect.value;
                const fullList = VOCAB_SETS[key] || VOCAB_SETS['animals'];
                
                let sourceList = [];
                // Check if user has specific selection for this category
                if (categorySelections[key] && categorySelections[key].length > 0) {
                    sourceList = categorySelections[key];
                } else {
                    // Default random pool
                    sourceList = fullList;
                }

                // If explicit selection, use all of them (up to reasonable limit or just all?)
                // If explicit, we trust user wants THESE words.
                // But poolSlider still exists. If user selects 20 words but pool is 8?
                // Better behavior: If selection exists, it overrides random shuffle, but we still might need to clamp or shuffle the selection if it's huge?
                // User said: "If I don't choose anything... assume random."
                
                // Logic: 
                // 1. Shuffle source
                const shuffled = [...sourceList].sort(() => 0.5 - Math.random());
                
                // 2. Pick 'poolSize' amount OR all if selection < poolSize
                // If manual selection is active, we should probably try to use ALL of them if possible,
                // but let's respect poolSize as a "Game Length/Variety" limiter.
                // However, usually manual select means "Drill THESE 4 words".
                // So if manual selection exists, lets use that list length as the pool size implicitly, or clamp?
                // Let's stick to Pool Slider as master count, unless selection < Pool Slider.
                
                const count = Math.min(poolSize, shuffled.length);
                const subset = shuffled.slice(0, count);
                
                sessionPool = subset.map(w => {
                     const lower = w.toLowerCase();
                     return {
                         t: w,
                         e: EMOJI_MAP.get(lower) || null
                     };
                });
            }
        }

        // --- Scheduler & Play Logic ---
        let pendingRoundChange = false; 

        function showOverlay(text) {
            overlayContent.innerText = text;
            overlayContainer.classList.remove('opacity-0');
            overlayContent.classList.remove('scale-90');
            overlayContent.classList.add('scale-100');
            setTimeout(() => {
                overlayContainer.classList.add('opacity-0');
                overlayContent.classList.remove('scale-100');
                overlayContent.classList.add('scale-90');
            }, 1500);
        }

        function nextNote() {
            const secondsPerBeat = 60.0 / bpm;
            nextNoteTime += secondsPerBeat;
            
            if (currentRound > totalRounds) {
                finishingCounter++;
                if (finishingCounter >= 2) stopGame(true);
                return;
            }
            
            if (isIntermission) {
                intermissionCounter++;
                if (intermissionCounter >= 4) {
                    isIntermission = false;
                    intermissionCounter = 0;
                    currentRound++;
                    pendingRoundChange = true;
                    if (isCustomMode && currentRound <= totalRounds) {
                         const nextRoundData = customRoundsData[currentRound - 1];
                         if (nextRoundData) itemCount = nextRoundData.length;
                    }
                    currentBeatIndex = 0;
                    currentLoop = 1;
                    setTimeout(() => {
                        if (isPlaying) {
                            updateRoundStatus();
                            showOverlay("MEMORIZE");
                        }
                    }, 0);
                }
                return;
            }

            if (isLoopTransition) {
                loopTransitionCounter++;
                if (loopTransitionCounter >= 4) { 
                    isLoopTransition = false;
                    loopTransitionCounter = 0;
                    currentLoop++;
                    currentBeatIndex = 0;
                    setTimeout(() => {
                        if(isPlaying) showOverlay("CHANT!");
                    }, 0);
                }
                return;
            }

            currentBeatIndex++;
            if (currentBeatIndex >= itemCount) {
                currentBeatIndex = 0;
                if (currentLoop < LOOPS_PER_ROUND) {
                    isLoopTransition = true;
                    loopTransitionCounter = 0;
                } else {
                    if (currentRound < totalRounds) {
                        isIntermission = true;
                        intermissionCounter = 0;
                        setTimeout(() => {
                            if (isPlaying) {
                                statusText.innerText = "GET READY...";
                                statusText.classList.remove('text-blue-400', 'text-green-400');
                                statusText.classList.add('text-yellow-400');
                                statusText.style.opacity = '1';
                            }
                        }, 0);
                    } else {
                        currentRound++; 
                        finishingCounter = 0;
                        setTimeout(() => {
                            if (isPlaying) updateRoundStatus();
                        }, 0);
                    }
                }
            }
        }

        function scheduler() {
            while (nextNoteTime < audioCtx.currentTime + SCHEDULE_AHEAD_TIME) {
                if (currentRound <= totalRounds) {
                    scheduleNote(currentBeatIndex, nextNoteTime, pendingRoundChange, isIntermission, isLoopTransition);
                } else {
                    playHiHat(nextNoteTime);
                }
                if (pendingRoundChange && currentBeatIndex === 0) pendingRoundChange = false;
                nextNote();
                if (!isPlaying) break; 
            }
            if (isPlaying) timerID = window.setTimeout(scheduler, LOOKAHEAD);
        }

        function scheduleNote(beatNumber, time, isNewRoundStart, intermissionActive, loopTransitionActive) {
            if (intermissionActive) {
                playStick(time);
                // Clear Visuals
                const timeToEvent = (time - audioCtx.currentTime) * 1000;
                setTimeout(() => {
                     if(!isPlaying) return;
                     const cards = gameGrid.children;
                     for (let i = 0; i < cards.length; i++) {
                        cards[i].classList.remove('card-active');
                        const emoji = cards[i].querySelector('.emoji-content');
                        if(emoji) emoji.classList.remove('scale-125');
                     }
                }, Math.max(0, timeToEvent));
                return;
            }

            if (loopTransitionActive) {
                // Rhythmic Fill: High pitch on last beat
                if (loopTransitionCounter === 3) playStick(time, true); 
                else {
                    if (loopTransitionCounter % 2 === 0) playHiHat(time);
                    else playSnare(time); 
                }
                
                const timeToEvent = (time - audioCtx.currentTime) * 1000;
                setTimeout(() => {
                     if(!isPlaying) return;
                     const cards = gameGrid.children;
                     for (let i = 0; i < cards.length; i++) cards[i].classList.remove('card-active');
                }, Math.max(0, timeToEvent));
                return;
            }

            const bassFreq = currentLoop === 1 ? 130.81 : 196.00; 
            playKick(time);
            playHiHat(time);
            playBass(time, bassFreq);
            if (beatNumber % 2 !== 0) playSnare(time);

            const timeToEvent = (time - audioCtx.currentTime) * 1000;
            setTimeout(() => {
                updateVisuals(beatNumber, isNewRoundStart);
            }, Math.max(0, timeToEvent));
        }

        // --- Visual Logic ---
        function generateGridItems() {
            gameGrid.innerHTML = '';
            let selected = [];

            if (isCustomMode) {
                const roundIndex = (currentRound - 1);
                if (roundIndex < customRoundsData.length) selected = customRoundsData[roundIndex];
                else selected = customRoundsData[0]; 
                
                itemCount = selected.length;
                gridSlider.value = itemCount;
                gridDisplay.innerText = itemCount;
            } else {
                // Logic to pick words based on pool and difficulty
                const shuffledPool = [...sessionPool].sort(() => 0.5 - Math.random());
                let uniqueCountLimit = 8; 
                if (currentRound === 1) uniqueCountLimit = 2;
                else if (currentRound === 2) uniqueCountLimit = Math.random() < 0.5 ? 3 : 4;
                else if (currentRound === 3) uniqueCountLimit = Math.random() < 0.5 ? 5 : 6;
                else if (currentRound === 4) uniqueCountLimit = 7;
                else uniqueCountLimit = 8;
                
                uniqueCountLimit = Math.min(uniqueCountLimit, sessionPool.length);
                const uniquePicks = shuffledPool.slice(0, uniqueCountLimit);

                const grammarKey = grammarSelect.value;
                const grammarTemplates = {
                    'svo_like': ["I", "like", "%word%"],
                    'svo_see': ["I", "see", "a", "%word%"],
                    'prep_on': ["On", "the", "%word%"],
                    'prep_under': ["Under", "the", "%word%"],
                    'comp_than': ["Bigger", "than", "%word%"],
                    'passive': ["The", "%word%", "was", "seen"]
                };

                let gridTokens = [];
                let pickIndex = 0;

                if (grammarKey === 'none') {
                    for(let i=0; i<itemCount; i++) {
                        gridTokens.push(uniquePicks[i % uniquePicks.length].t);
                    }
                    gridTokens.sort(() => 0.5 - Math.random());
                } else {
                    const template = grammarTemplates[grammarKey];
                    while(gridTokens.length < itemCount) {
                        const wordObject = uniquePicks[pickIndex % uniquePicks.length];
                        const word = wordObject.t; 
                        pickIndex++;
                        const tokens = template.map(t => t === "%word%" ? word : t);
                        gridTokens.push(...tokens);
                    }
                    gridTokens = gridTokens.slice(0, itemCount);
                }

                selected = gridTokens.map(token => {
                    const poolMatch = sessionPool.find(p => p.t.toLowerCase() === token.toLowerCase());
                    const emoji = poolMatch ? poolMatch.e : null;
                    return { t: token, e: emoji };
                });
            }

            // Layout Calculation
            let count = selected.length;
            let cols = 2;
            if (count <= 4) cols = 2;
            else if (count <= 6) cols = 3;
            else if (count <= 9) cols = 3; 
            else if (count <= 12) cols = 4;
            else cols = 4;
            
            gameGrid.style.gridTemplateColumns = `repeat(${cols}, minmax(0, 1fr))`;

            // Color Logic
            const colorMap = {
                red: 'text-red-500', blue: 'text-blue-500', green: 'text-green-500',
                yellow: 'text-yellow-400', orange: 'text-orange-500', purple: 'text-purple-500',
                pink: 'text-pink-500', brown: 'text-amber-600', white: 'text-white',
                cyan: 'text-cyan-400', magenta: 'text-fuchsia-500', lime: 'text-lime-400',
                indigo: 'text-indigo-400', violet: 'text-violet-400', teal: 'text-teal-400',
                gold: 'text-yellow-300', silver: 'text-gray-300'
            };

            selected.forEach((item, index) => {
                const card = document.createElement('div');
                card.id = `card-${index}`;
                card.className = "card bg-slate-800 border-2 border-slate-700 rounded-2xl flex flex-col items-center justify-center aspect-square p-1 select-none relative overflow-hidden";
                
                let textClass = 'text-white';
                let labelClass = 'text-slate-400';
                const lowerT = item.t.toLowerCase();
                if (colorMap[lowerT]) {
                    textClass = colorMap[lowerT];
                    labelClass = colorMap[lowerT];
                }

                if (item.e && showEmojis) {
                    let labelSize = item.t.length > 15 ? 'text-xs md:text-sm' : 'text-sm md:text-2xl';
                    card.innerHTML = `
                        <div class="emoji-content text-7xl md:text-9xl mb-0 drop-shadow-lg scale-100 transition-transform duration-200 leading-none">${item.e}</div>
                        <div class="absolute bottom-1 md:bottom-2 ${labelSize} font-bold ${labelClass} tracking-wide leading-none">${item.t}</div>
                    `;
                } else {
                     let fontSize = item.t.length > 15 ? 'text-3xl md:text-5xl' : (item.t.length > 7 ? 'text-4xl md:text-6xl' : 'text-6xl md:text-8xl');
                     card.innerHTML = `
                        <div class="${fontSize} font-black ${textClass} text-center leading-none tracking-tight px-1 break-words w-full">${item.t}</div>
                    `;
                }
                gameGrid.appendChild(card);
            });
        }

        function updateVisuals(beatIndex, isNewRoundStart) {
            if (!isPlaying) return;
            if (isNewRoundStart) generateGridItems();

            const cards = gameGrid.children;
            for (let i = 0; i < cards.length; i++) {
                cards[i].classList.remove('card-active');
                const emoji = cards[i].querySelector('.emoji-content');
                if(emoji) emoji.classList.remove('scale-125');
            }

            const currentCard = document.getElementById(`card-${beatIndex}`);
            if (currentCard) {
                currentCard.classList.add('card-active');
                const emoji = currentCard.querySelector('.emoji-content');
                if(emoji) emoji.classList.add('scale-125');
            }
        }

        function updateRoundStatus() {
            if (currentRound <= totalRounds) {
                statusText.innerText = `ROUND ${currentRound}/${totalRounds}`;
                statusText.classList.remove('text-green-400', 'text-yellow-400');
                statusText.classList.add('text-blue-400');
            }
        }

        // --- Controls & Event Listeners ---
        
        function stopGame(finished = false) {
            isPlaying = false;
            window.clearTimeout(timerID);
            btnText.innerHTML = `<span>‚ñ∂</span> START`;
            toggleBtn.classList.remove('btn-pulse', 'bg-rose-600', 'hover:bg-rose-500');
            toggleBtn.classList.add('bg-blue-600', 'hover:bg-blue-500');
            overlayContainer.classList.add('opacity-0');
            if (finished) {
                statusText.innerText = "FINISH!";
                statusText.classList.remove('text-blue-400', 'text-yellow-400');
                statusText.classList.add('text-green-400');
                playChord(audioCtx.currentTime);
            } else {
                statusText.style.opacity = '0';
            }
            currentBeatIndex = 0;
            document.querySelectorAll('.card').forEach(c => c.classList.remove('card-active'));
        }

        function startGame() {
            initAudio();
            initSessionPool(); 
            isPlaying = true;
            currentBeatIndex = 0;
            currentRound = 1;
            currentLoop = 1;
            pendingRoundChange = false;
            isIntermission = false;
            intermissionCounter = 0;
            isLoopTransition = false;
            loopTransitionCounter = 0;
            finishingCounter = 0;
            if (isCustomMode && customRoundsData.length > 0) itemCount = customRoundsData[0].length;
            generateGridItems(); 
            nextNoteTime = audioCtx.currentTime + 0.1;
            btnText.innerHTML = `<span>‚èπ</span> STOP`;
            toggleBtn.classList.remove('bg-blue-600', 'hover:bg-blue-500');
            toggleBtn.classList.add('btn-pulse', 'bg-rose-600', 'hover:bg-rose-500');
            updateRoundStatus();
            statusText.style.opacity = '1';
            setTimeout(() => { showOverlay("MEMORIZE"); }, 100);
            scheduler();
        }

        function toggleGame() {
            if (isPlaying) stopGame(false);
            else startGame();
        }

        function setCustomMode(active) {
            isCustomMode = active;
            if (active) {
                shuffleBtn.style.display = 'none';
                filterBtn.style.display = 'none'; // Hide filter in custom text mode
                gridSlider.disabled = true; gridSlider.parentElement.style.opacity = '0.5';
                poolSlider.disabled = true; poolSlider.parentElement.style.opacity = '0.5';
                editBtn.innerHTML = '<span class="text-blue-400">‚óè</span>';
                vocabSelect.disabled = true; grammarSelect.disabled = true;
                vocabSelect.classList.add('opacity-50'); grammarSelect.classList.add('opacity-50');
            } else {
                totalRounds = 5;
                shuffleBtn.style.display = 'flex';
                filterBtn.style.display = 'flex';
                gridSlider.disabled = false; gridSlider.parentElement.style.opacity = '1';
                poolSlider.disabled = false; poolSlider.parentElement.style.opacity = '1';
                editBtn.innerHTML = '<span>‚úé</span>';
                vocabSelect.disabled = false; grammarSelect.disabled = false;
                vocabSelect.classList.remove('opacity-50'); grammarSelect.classList.remove('opacity-50');
            }
        }

        toggleBtn.addEventListener('click', toggleGame);
        shuffleBtn.addEventListener('click', () => { if(!isCustomMode) { initSessionPool(); generateGridItems(); } });
        editBtn.addEventListener('click', () => {
            customModal.classList.remove('modal-enter'); customModal.classList.add('modal-active');
        });
        cancelCustomBtn.addEventListener('click', () => {
            customModal.classList.remove('modal-active'); customModal.classList.add('modal-enter');
        });
        applyCustomBtn.addEventListener('click', applyCustomWords);
        
        previewBtn.addEventListener('click', openPreview);
        closePreviewBtn.addEventListener('click', closePreview);
        
        filterBtn.addEventListener('click', openSelectionModal);
        closeSelectionBtn.addEventListener('click', closeSelectionModal);
        saveSelectionBtn.addEventListener('click', saveSelection);

        vocabSelect.addEventListener('change', () => {
            if(!isCustomMode) { if(isPlaying) stopGame(false); initSessionPool(); generateGridItems(); }
        });
        grammarSelect.addEventListener('change', () => {
            if(!isCustomMode) { if(isPlaying) stopGame(false); generateGridItems(); }
        });
        bpmSlider.addEventListener('input', (e) => {
            bpm = parseInt(e.target.value); bpmDisplay.innerText = `${bpm}`;
        });
        gridSlider.addEventListener('input', (e) => {
            const val = parseInt(e.target.value); itemCount = val; gridDisplay.innerText = val;
            if (!isPlaying && !isCustomMode) generateGridItems();
        });
        poolSlider.addEventListener('input', (e) => {
            poolSize = parseInt(e.target.value); poolDisplay.innerText = poolSize;
            if(!isCustomMode && !isPlaying) { initSessionPool(); generateGridItems(); }
        });
        emojiToggle.addEventListener('change', (e) => {
            showEmojis = e.target.checked; generateGridItems();
        });

        // --- Selection Modal Logic ---
        function openSelectionModal() {
            if(isPlaying) stopGame(false);
            const key = vocabSelect.value;
            const fullList = VOCAB_SETS[key] || [];
            const currentSelection = categorySelections[key] || [];
            
            selectionList.innerHTML = '';
            fullList.forEach(word => {
                const isChecked = currentSelection.length === 0 || currentSelection.includes(word);
                const wrapper = document.createElement('label');
                wrapper.className = "flex items-center space-x-3 p-2 bg-slate-700 rounded-lg cursor-pointer hover:bg-slate-600 transition";
                wrapper.innerHTML = `
                    <input type="checkbox" value="${word}" class="custom-checkbox appearance-none h-5 w-5 border border-slate-500 rounded bg-slate-800 checked:bg-blue-600 checked:border-blue-600 relative transition" ${isChecked ? 'checked' : ''}>
                    <span class="text-white select-none">${word}</span>
                `;
                selectionList.appendChild(wrapper);
            });
            
            selectionModal.classList.remove('modal-enter'); selectionModal.classList.add('modal-active');
        }

        function closeSelectionModal() {
            selectionModal.classList.remove('modal-active'); selectionModal.classList.add('modal-enter');
        }

        function saveSelection() {
            const key = vocabSelect.value;
            const checkboxes = selectionList.querySelectorAll('input[type="checkbox"]');
            const selected = [];
            checkboxes.forEach(cb => {
                if(cb.checked) selected.push(cb.value);
            });
            
            // If all or none are checked, treat as empty (means ALL/Random) to avoid restrictive behavior
            // Or strictly respect selection. User asked: "If I don't choose anything... assume random."
            // If user unchecks ALL, then random.
            
            if (selected.length === 0) {
                categorySelections[key] = []; // Clear
            } else {
                categorySelections[key] = selected;
            }
            
            closeSelectionModal();
            initSessionPool();
            generateGridItems();
        }

        function applyCustomWords() {
            const rawText = customInput.value.trim();
            if (!rawText) {
                setCustomMode(false); initSessionPool(); generateGridItems();
            } else {
                const lines = rawText.split('\n').filter(line => line.trim().length > 0);
                if (lines.length === 0) return;
                const parsedRounds = lines.map(line => {
                    const words = line.trim().split(/\s+/).filter(w => w.length > 0);
                    return words.map(word => {
                        const lower = word.toLowerCase();
                        const emoji = EMOJI_MAP.get(lower) || null;
                        return { t: word, e: emoji, isSentence: false };
                    });
                }).filter(round => round.length > 0); 
                if (parsedRounds.length === 0) return;
                customRoundsData = parsedRounds;
                totalRounds = parsedRounds.length;
                setCustomMode(true);
                initSessionPool(); 
                currentRound = 1; currentLoop = 1; itemCount = parsedRounds[0].length;
                generateGridItems();
            }
            customModal.classList.remove('modal-active'); customModal.classList.add('modal-enter');
            if (isPlaying) stopGame(false); 
        }

        // --- Preview Logic (Carousel) ---
        function openPreview() {
            if(isPlaying) stopGame(false);
            if(sessionPool.length === 0) initSessionPool();
            currentPreviewIndex = 0;
            renderPreviewCard(currentPreviewIndex);
            previewModal.classList.remove('modal-enter'); previewModal.classList.add('modal-active');
        }

        function closePreview() {
            previewModal.classList.remove('modal-active'); previewModal.classList.add('modal-enter');
        }

        function renderPreviewCard(index) {
            flashcardContainer.innerHTML = '';
            
            if (sessionPool.length === 0) return;
            const item = sessionPool[index];
            previewCounter.innerText = `${index + 1} / ${sessionPool.length}`;

            // Flashcard Style
            const card = document.createElement('div');
            card.className = "w-full h-full bg-white border border-slate-200 border-b-8 border-r-8 border-slate-300 rounded-3xl p-6 flex flex-col items-center justify-center shadow-2xl relative overflow-hidden transition-all duration-300 transform";
            
            const colorMap = {
                red: 'text-red-600', blue: 'text-blue-600', green: 'text-green-600',
                yellow: 'text-yellow-500', orange: 'text-orange-600', purple: 'text-purple-600',
                pink: 'text-pink-600', brown: 'text-amber-800', white: 'text-slate-400',
                cyan: 'text-cyan-600', magenta: 'text-fuchsia-600', lime: 'text-lime-600',
                indigo: 'text-indigo-600', violet: 'text-violet-600', teal: 'text-teal-600',
                gold: 'text-yellow-600', silver: 'text-slate-400'
            };
            
            let textClass = 'text-slate-900';
            const lowerT = item.t.toLowerCase();
            if (colorMap[lowerT]) textClass = colorMap[lowerT];

            if (item.e && showEmojis) {
                 card.innerHTML = `
                    <div class="text-[8rem] mb-4 filter drop-shadow-sm select-none">${item.e}</div>
                    <div class="text-3xl font-bold text-slate-700 tracking-tight text-center px-1">${item.t}</div>
                `;
            } else {
                 card.innerHTML = `
                    <div class="text-5xl font-black ${textClass} text-center leading-tight break-words px-4 select-none">${item.t}</div>
                `;
            }
            flashcardContainer.appendChild(card);
        }

        function nextPreview() {
            if (sessionPool.length === 0) return;
            currentPreviewIndex = (currentPreviewIndex + 1) % sessionPool.length;
            renderPreviewCard(currentPreviewIndex);
        }

        function prevPreview() {
            if (sessionPool.length === 0) return;
            currentPreviewIndex = (currentPreviewIndex - 1 + sessionPool.length) % sessionPool.length;
            renderPreviewCard(currentPreviewIndex);
        }

        // Preview Nav Listeners
        prevCardBtn.addEventListener('click', prevPreview);
        nextCardBtn.addEventListener('click', nextPreview);

        // Swipe Logic
        let touchStartX = 0;
        let touchEndX = 0;
        
        flashcardContainer.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
        }, {passive: true});

        flashcardContainer.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        }, {passive: true});

        function handleSwipe() {
            const threshold = 50; 
            if (touchEndX < touchStartX - threshold) nextPreview(); // Swipe Left -> Next
            if (touchEndX > touchStartX + threshold) prevPreview(); // Swipe Right -> Prev
        }

        // Initial Load
        initSessionPool();
        generateGridItems();

    </script>
</body>
</html>